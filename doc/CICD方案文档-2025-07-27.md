# 个人摄影师微信小程序 - CI/CD方案文档

**文档版本：** v1.0  
**创建日期：** 2025-07-27  
**作者：** 开发团队  

## 📋 文档概述

本文档详细描述了个人摄影师微信小程序项目的持续集成和持续部署（CI/CD）方案，包括代码管理、自动化构建、测试、部署等完整流程。

## 🎯 CI/CD目标

### 主要目标
- **提高开发效率**：自动化构建、测试、部署流程
- **保证代码质量**：自动化代码检查、测试覆盖率检测
- **降低部署风险**：分阶段部署、自动回滚机制
- **快速反馈**：快速发现和修复问题
- **标准化流程**：统一的开发、测试、部署标准

### 核心原则
- **自动化优先**：尽可能自动化所有重复性工作
- **快速反馈**：构建和测试结果快速反馈给开发者
- **质量保证**：每次提交都经过完整的质量检查
- **安全可靠**：部署过程安全可控，支持快速回滚

## 🏗️ 整体架构

### CI/CD流程架构
```
┌─────────────────────────────────────────────────────────────┐
│                    开发者工作流                              │
└─────────────────┬───────────────────────────────────────────┘
                  │
    ┌─────────────▼─────────────┐
    │      Git Repository       │
    │    (GitHub/GitLab)        │
    └─────────────┬─────────────┘
                  │
    ┌─────────────▼─────────────┐
    │     CI/CD Pipeline        │
    │   (GitHub Actions/        │
    │    GitLab CI/Jenkins)     │
    └─────────────┬─────────────┘
                  │
    ┌─────────────▼─────────────┐
    │      构建阶段              │
    │  ┌─────────┐ ┌─────────┐  │
    │  │代码检查 │ │单元测试 │  │
    │  └─────────┘ └─────────┘  │
    │  ┌─────────┐ ┌─────────┐  │
    │  │安全扫描 │ │构建镜像 │  │
    │  └─────────┘ └─────────┘  │
    └─────────────┬─────────────┘
                  │
    ┌─────────────▼─────────────┐
    │      部署阶段              │
    │  ┌─────────┐ ┌─────────┐  │
    │  │测试环境  │ │预生产   │  │
    │  └─────────┘ └─────────┘  │
    │  ┌─────────┐              │
    │  │生产环境 │              │
    │  └─────────┘              │
    └─────────────┬─────────────┘
                  │
    ┌─────────────▼─────────────┐
    │      监控反馈              │
    │  ┌─────────┐ ┌─────────┐  │
    │  │应用监控  │ │日志分析 │  │
    │  └─────────┘ └─────────┘  │
    │  ┌─────────┐              │
    │  │告警通知  │              │
    │  └─────────┘              │
    └───────────────────────────┘
```

### 技术栈选型

#### CI/CD平台
- **主选方案**: GitHub Actions（与GitHub深度集成）
- **备选方案**: GitLab CI/CD 或 Jenkins
- **容器化**: Docker + Docker Compose
- **镜像仓库**: 阿里云容器镜像服务 ACR

#### 部署环境
- **开发环境**: 本地Docker环境
- **测试环境**: 阿里云ECS + Docker
- **预生产环境**: 阿里云ECS + Docker
- **生产环境**: 阿里云ECS集群 + Docker Swarm/K8s

#### 监控工具
- **应用监控**: Prometheus + Grafana
- **日志管理**: ELK Stack (Elasticsearch + Logstash + Kibana)
- **告警通知**: 钉钉/企业微信 Webhook

## 📁 项目结构与分支策略

### Git分支模型

#### 分支类型
```
main (生产分支)
├── develop (开发分支)
│   ├── feature/user-auth (功能分支)
│   ├── feature/portfolio-mgmt (功能分支)
│   └── feature/promotion-system (功能分支)
├── release/v1.0.0 (发布分支)
├── hotfix/critical-bug-fix (热修复分支)
└── test/integration-test (测试分支)
```

#### 分支规则
1. **main分支**
   - 生产环境代码
   - 只接受来自release和hotfix分支的合并
   - 每次合并自动触发生产部署
   - 受保护，需要代码审查

2. **develop分支**
   - 开发环境代码
   - 功能分支的合并目标
   - 自动触发开发环境部署
   - 定期合并到release分支

3. **feature分支**
   - 功能开发分支
   - 从develop分支创建
   - 完成后合并回develop分支
   - 命名规范: feature/功能名称

4. **release分支**
   - 发布准备分支
   - 从develop分支创建
   - 用于发布前的最后测试和bug修复
   - 完成后合并到main和develop分支

5. **hotfix分支**
   - 紧急修复分支
   - 从main分支创建
   - 修复完成后合并到main和develop分支

### 提交规范

#### Commit Message格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

#### 类型说明
- **feat**: 新功能
- **fix**: 修复bug
- **docs**: 文档更新
- **style**: 代码格式调整
- **refactor**: 代码重构
- **test**: 测试相关
- **chore**: 构建过程或辅助工具的变动

#### 示例
```
feat(auth): 添加微信登录功能

- 实现微信授权登录接口
- 添加JWT Token生成和验证
- 完善用户信息存储逻辑

Closes #123
```

## 🔄 CI/CD流水线设计

### GitHub Actions工作流

#### 1. 代码质量检查工作流
```yaml
# .github/workflows/code-quality.yml
name: Code Quality Check

on:
  pull_request:
    branches: [ develop, main ]
  push:
    branches: [ develop ]

jobs:
  code-quality:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        
    - name: Run Checkstyle
      run: mvn checkstyle:check
      
    - name: Run SpotBugs
      run: mvn spotbugs:check
      
    - name: Run PMD
      run: mvn pmd:check
      
    - name: SonarQube Scan
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: mvn sonar:sonar
```

#### 2. 单元测试工作流
```yaml
# .github/workflows/unit-tests.yml
name: Unit Tests

on:
  pull_request:
    branches: [ develop, main ]
  push:
    branches: [ develop, main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: shoot_sunrise_test
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: --health-cmd="redis-cli ping" --health-interval=10s --health-timeout=5s --health-retries=3
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        
    - name: Run unit tests
      run: mvn clean test
      env:
        SPRING_PROFILES_ACTIVE: test
        
    - name: Generate test report
      run: mvn jacoco:report
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./target/site/jacoco/jacoco.xml
        
    - name: Publish test results
      uses: dorny/test-reporter@v1
      if: success() || failure()
      with:
        name: Maven Tests
        path: target/surefire-reports/*.xml
        reporter: java-junit
```

#### 3. 构建和部署工作流
```yaml
# .github/workflows/build-deploy.yml
name: Build and Deploy

on:
  push:
    branches: [ develop, main ]
  release:
    types: [ published ]

env:
  REGISTRY: registry.cn-hangzhou.aliyuncs.com
  NAMESPACE: shootsunrise

jobs:
  build:
    runs-on: ubuntu-latest
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        
    - name: Build application
      run: mvn clean package -DskipTests
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
      
    - name: Login to Aliyun Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.ALIYUN_USERNAME }}
        password: ${{ secrets.ALIYUN_PASSWORD }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/shoot-sunrise-backend
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=sha,prefix={{branch}}-
          
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-dev:
    if: github.ref == 'refs/heads/develop'
    needs: build
    runs-on: ubuntu-latest
    environment: development
    
    steps:
    - name: Deploy to development
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.DEV_HOST }}
        username: ${{ secrets.DEV_USERNAME }}
        key: ${{ secrets.DEV_SSH_KEY }}
        script: |
          docker pull ${{ needs.build.outputs.image-tag }}
          docker-compose -f /opt/shootsunrise/docker-compose.dev.yml up -d
          
  deploy-staging:
    if: startsWith(github.ref, 'refs/heads/release/')
    needs: build
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
    - name: Deploy to staging
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        script: |
          docker pull ${{ needs.build.outputs.image-tag }}
          docker-compose -f /opt/shootsunrise/docker-compose.staging.yml up -d
          
  deploy-prod:
    if: github.ref == 'refs/heads/main'
    needs: build
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Deploy to production
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        script: |
          docker pull ${{ needs.build.outputs.image-tag }}
          docker-compose -f /opt/shootsunrise/docker-compose.prod.yml up -d --no-deps backend
          
    - name: Health check
      run: |
        sleep 30
        curl -f ${{ secrets.PROD_URL }}/actuator/health || exit 1
        
    - name: Notify deployment
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

## 🐳 Docker容器化配置

### 后端应用Dockerfile
```dockerfile
# Dockerfile
FROM openjdk:17-jdk-slim as builder

WORKDIR /app
COPY pom.xml .
COPY src ./src
COPY .mvn ./.mvn
COPY mvnw .

RUN chmod +x mvnw
RUN ./mvnw clean package -DskipTests

FROM openjdk:17-jre-slim

# 安装必要的工具
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 创建应用用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

WORKDIR /app

# 复制应用jar包
COPY --from=builder /app/target/*.jar app.jar

# 创建日志目录
RUN mkdir -p /app/logs && chown -R appuser:appuser /app

# 切换到非root用户
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# 暴露端口
EXPOSE 8080

# JVM参数优化
ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC -XX:+UseContainerSupport"

# 启动应用
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 管理后台Dockerfile
```dockerfile
# admin-frontend/Dockerfile
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine

# 复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制nginx配置
COPY nginx.conf /etc/nginx/nginx.conf

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:80/health || exit 1

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### Docker Compose配置

#### 开发环境配置
```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  backend:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - DB_HOST=mysql
      - REDIS_HOST=redis
    depends_on:
      - mysql
      - redis
    volumes:
      - ./logs:/app/logs
    networks:
      - app-network

  admin-frontend:
    build: ./admin-frontend
    ports:
      - "3000:80"
    depends_on:
      - backend
    networks:
      - app-network

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: shoot_sunrise
      MYSQL_USER: app
      MYSQL_PASSWORD: password
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/dev.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - backend
      - admin-frontend
    networks:
      - app-network

volumes:
  mysql_data:
  redis_data:

networks:
  app-network:
    driver: bridge
```

#### 生产环境配置
```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  backend:
    image: registry.cn-hangzhou.aliyuncs.com/shootsunrise/shoot-sunrise-backend:latest
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_HOST=mysql
      - REDIS_HOST=redis
    depends_on:
      - mysql
      - redis
    volumes:
      - /opt/shootsunrise/logs:/app/logs
    networks:
      - app-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  admin-frontend:
    image: registry.cn-hangzhou.aliyuncs.com/shootsunrise/admin-frontend:latest
    deploy:
      replicas: 1
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
    depends_on:
      - backend
    networks:
      - app-network

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD_FILE: /run/secrets/mysql_root_password
      MYSQL_DATABASE: shoot_sunrise
      MYSQL_USER: app
      MYSQL_PASSWORD_FILE: /run/secrets/mysql_password
    volumes:
      - /opt/shootsunrise/mysql:/var/lib/mysql
      - /opt/shootsunrise/backup:/backup
    networks:
      - app-network
    secrets:
      - mysql_root_password
      - mysql_password
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  redis:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - /opt/shootsunrise/redis:/data
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /opt/shootsunrise/nginx/prod.conf:/etc/nginx/nginx.conf
      - /opt/shootsunrise/ssl:/etc/nginx/ssl
      - /opt/shootsunrise/logs/nginx:/var/log/nginx
    depends_on:
      - backend
      - admin-frontend
    networks:
      - app-network

secrets:
  mysql_root_password:
    external: true
  mysql_password:
    external: true

networks:
  app-network:
    driver: overlay
    attachable: true
```

## 🚀 部署策略

### 环境划分

#### 1. 开发环境 (Development)
- **目的**: 开发人员日常开发测试
- **触发条件**: 推送到develop分支
- **部署方式**: 自动部署
- **数据**: 测试数据
- **域名**: dev.shootsunrise.com

#### 2. 测试环境 (Testing)
- **目的**: QA团队功能测试
- **触发条件**: 创建release分支
- **部署方式**: 自动部署
- **数据**: 模拟生产数据
- **域名**: test.shootsunrise.com

#### 3. 预生产环境 (Staging)
- **目的**: 生产前最后验证
- **触发条件**: release分支测试通过
- **部署方式**: 手动审批后自动部署
- **数据**: 生产数据副本
- **域名**: staging.shootsunrise.com

#### 4. 生产环境 (Production)
- **目的**: 正式对外服务
- **触发条件**: 合并到main分支
- **部署方式**: 手动审批后自动部署
- **数据**: 生产数据
- **域名**: www.shootsunrise.com

### 部署策略

#### 蓝绿部署
```bash
#!/bin/bash
# deploy-blue-green.sh

# 配置变量
BLUE_CONTAINER="backend-blue"
GREEN_CONTAINER="backend-green"
NGINX_CONFIG="/opt/shootsunrise/nginx/upstream.conf"
NEW_IMAGE="$1"

# 检查当前活跃容器
CURRENT_ACTIVE=$(docker ps --format "table {{.Names}}" | grep -E "(backend-blue|backend-green)" | head -1)

if [[ "$CURRENT_ACTIVE" == *"blue"* ]]; then
    ACTIVE_CONTAINER="$BLUE_CONTAINER"
    STANDBY_CONTAINER="$GREEN_CONTAINER"
    NEW_UPSTREAM="green"
else
    ACTIVE_CONTAINER="$GREEN_CONTAINER"
    STANDBY_CONTAINER="$BLUE_CONTAINER"
    NEW_UPSTREAM="blue"
fi

echo "当前活跃容器: $ACTIVE_CONTAINER"
echo "准备部署到: $STANDBY_CONTAINER"

# 1. 部署新版本到standby环境
echo "部署新版本..."
docker stop $STANDBY_CONTAINER 2>/dev/null || true
docker rm $STANDBY_CONTAINER 2>/dev/null || true
docker run -d --name $STANDBY_CONTAINER \
    --network app-network \
    -e SPRING_PROFILES_ACTIVE=prod \
    $NEW_IMAGE

# 2. 健康检查
echo "等待应用启动..."
sleep 30

for i in {1..10}; do
    if docker exec $STANDBY_CONTAINER curl -f http://localhost:8080/actuator/health; then
        echo "健康检查通过"
        break
    fi
    if [ $i -eq 10 ]; then
        echo "健康检查失败，回滚部署"
        docker stop $STANDBY_CONTAINER
        exit 1
    fi
    sleep 10
done

# 3. 切换流量
echo "切换流量到新版本..."
sed -i "s/server backend-.*;/server backend-$NEW_UPSTREAM:8080;/" $NGINX_CONFIG
docker exec nginx nginx -s reload

# 4. 验证切换
sleep 10
if curl -f http://localhost/actuator/health; then
    echo "流量切换成功"
    # 停止旧版本
    docker stop $ACTIVE_CONTAINER
    echo "部署完成"
else
    echo "流量切换失败，回滚..."
    sed -i "s/server backend-.*;/server $ACTIVE_CONTAINER:8080;/" $NGINX_CONFIG
    docker exec nginx nginx -s reload
    docker stop $STANDBY_CONTAINER
    exit 1
fi
```

#### 滚动更新
```bash
#!/bin/bash
# rolling-update.sh

NEW_IMAGE="$1"
SERVICE_NAME="backend"
REPLICAS=3

echo "开始滚动更新..."

# 1. 更新Docker Swarm服务
docker service update \
    --image $NEW_IMAGE \
    --update-parallelism 1 \
    --update-delay 30s \
    --update-failure-action rollback \
    --update-monitor 60s \
    $SERVICE_NAME

# 2. 监控更新进度
echo "监控更新进度..."
while true; do
    STATUS=$(docker service ps $SERVICE_NAME --format "table {{.CurrentState}}" | grep -v "CurrentState")
    RUNNING=$(echo "$STATUS" | grep "Running" | wc -l)

    if [ $RUNNING -eq $REPLICAS ]; then
        echo "滚动更新完成"
        break
    fi

    echo "当前运行实例: $RUNNING/$REPLICAS"
    sleep 10
done

# 3. 健康检查
echo "执行健康检查..."
for i in {1..5}; do
    if curl -f http://localhost/actuator/health; then
        echo "健康检查通过，更新成功"
        exit 0
    fi
    sleep 10
done

echo "健康检查失败，执行回滚"
docker service rollback $SERVICE_NAME
exit 1
```

## 📊 监控与告警

### 应用监控配置

#### Prometheus配置
```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'shoot-sunrise-backend'
    static_configs:
      - targets: ['backend:8080']
    metrics_path: '/actuator/prometheus'
    scrape_interval: 10s

  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx:9113']

  - job_name: 'mysql'
    static_configs:
      - targets: ['mysql-exporter:9104']

  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

#### 告警规则
```yaml
# alert_rules.yml
groups:
  - name: application
    rules:
      - alert: ApplicationDown
        expr: up{job="shoot-sunrise-backend"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "应用服务不可用"
          description: "{{ $labels.instance }} 应用服务已停止响应超过1分钟"

      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "应用错误率过高"
          description: "{{ $labels.instance }} 5xx错误率超过10%"

      - alert: HighResponseTime
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "应用响应时间过长"
          description: "{{ $labels.instance }} 95%请求响应时间超过1秒"

  - name: infrastructure
    rules:
      - alert: HighCPUUsage
        expr: 100 - (avg by(instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "CPU使用率过高"
          description: "{{ $labels.instance }} CPU使用率超过80%"

      - alert: HighMemoryUsage
        expr: (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 85
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "内存使用率过高"
          description: "{{ $labels.instance }} 内存使用率超过85%"

      - alert: DiskSpaceLow
        expr: (1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100 > 90
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "磁盘空间不足"
          description: "{{ $labels.instance }} 磁盘使用率超过90%"
```

### 日志管理

#### Logback配置
```xml
<!-- logback-spring.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <springProfile name="!prod">
        <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        <root level="INFO">
            <appender-ref ref="CONSOLE"/>
        </root>
    </springProfile>

    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>/app/logs/application.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>/app/logs/application.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                    <maxFileSize>100MB</maxFileSize>
                </timeBasedFileNamingAndTriggeringPolicy>
                <maxHistory>30</maxHistory>
                <totalSizeCap>3GB</totalSizeCap>
            </rollingPolicy>
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <message/>
                    <mdc/>
                    <stackTrace/>
                </providers>
            </encoder>
        </appender>

        <root level="INFO">
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
</configuration>
```

---

**文档状态：** ✅ 已完成
**下一步：** 开始实施CI/CD流水线
**联系人：** 开发团队
